# Sliding Number Puzzle

## Project Description
This project is a school assignment developed for the C++ Programming course, created by authors Annabel and Egert.

### Project Idea:
The Sliding Number Puzzle is a classic logic game where the player has to rearrange numbered tiles in a grid by sliding them into an empty space. The goal is to order the numbers in ascending order using as few moves as possible.

The game consists of an NxN grid, where all the cells except one are filled with numbered tiles. The empty cell is placed randomly.
For example, in a 4x4 grid, the numbers range from [1, 15]. When the player clicks on a tile adjacent to the empty space, that tile moves into the empty spot. If the tile is not adjacent to the empty space, nothing happens. The tiles can only move horizontally or vertically, not diagonally. At the beginning, the numbers are scrambled, and the goal of the game is to arrange the numbers in ascending order.

## Project Structure
### Graphical User Interface:
* The user interface is built using Dear ImGui library along with SDL3 and OpenGL3 for rendering.
* The puzzle grid is displayed graphically.
* The player can move tiles by clicking on them.
* A label next to the game grid displays the number of moves made.
* Timer tracks and displays the elapsed time since the puzzle started.
* Animated sliding of tiles when moved.
* Automatic puzzle solver (3x3) using the A* search algorithm.

## Solvability Check
It is important that the generated puzzle is solvable. We verify solvability based on the number of inversions and the position of the empty tile (0), depending on the grid size (NxN):

* For odd-sized grids (e.g., 3x3), the puzzle is solvable if the number of inversions is even.

* For even-sized grids (e.g., 4x4), solvability depends on both the number of inversions and the row of the empty tile counted from the bottom. The exact rules are:

  * If the empty tile is on an odd row from the bottom, the number of inversions must be even.

  * If the empty tile is on an even row from the bottom, the number of inversions must be odd.

## Automatic Solver
The project includes an automatic solver implemented with the A* algorithm.

Key features and methods used:

 * Heuristic: The solver uses the Manhattan distance as a heuristic, calculating the sum of the horizontal and vertical distances of each tile from its correct position.

* Neighbor generation: Possible next states are generated by sliding the empty tile (0) up, down, left, or right when those moves are valid.

* Data structures: A priority queue manages open states ordered by their estimated total cost (g + h), and a map tracks visited states and their costs.

**Limitations:** Due to exponential growth in the number of possible states, this solver is practical only for smaller puzzles like 3x3 grids. Larger grids (4x4 and above) cause significant computational overhead, making the solver too slow for real-time use without further optimizations.

Once the solution is found, the solver returns the sequence of states from the initial to the solved configuration, which can be used to visualize or automatically play the solution in the game.
## How to Run
Download the repository and compile the program using make. By default, the executable will be placed in the ```build``` directory.

To run the executable, ensure that ```SDL3.dll``` is located in the same directory as the executable. You can find ```SDL3.dll``` in the ```build``` directory.